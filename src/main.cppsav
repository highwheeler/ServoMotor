#include <Arduino.h>
#include <lvgl.h>
#include "FS.h"
#include <TFT_eSPI.h>
#include <Ticker.h>
#include "soc/ledc_reg.h"
#include "soc/ledc_struct.h"
#include "esp_task_wdt.h"
// THIS IS THE H BRIDGE PID VERSION!

#define CALIBRATION_FILE "/TouchCalData"
#define SETTINGS_FILE "/SettingsData"
#define REPEAT_CAL false
#define LVGL_TICK_PERIOD 20
#define HOR_RES 320
#define VER_RES 240
#define M1PIND1 16
#define M1PIND2 17
#define M1QP1 21
#define M1QP2 22
// the number of the LED pin
const int ledPin = 2;

#define OUTPULSE 32
Ticker tick;

volatile long m1Ctr = 0;
volatile long m1Prev = 0;
// int m1Dest = 0;
volatile bool runFlg = false;

#define PWMOFFSET 115
double kp = 10;
double ki = 0.0;
double kd = 9;
volatile long error, error1, error2;
#define MAXERR 255
int SamplingRate = 200; // Read 1000 values in one second.
lv_obj_t *mainScr;
hw_timer_t *timer = NULL;
//hw_timer_t *pwmTimer = NULL;
volatile long m1Lst = 0;
#define NUMHIST 3
volatile int errHist[NUMHIST];
#define SUMMAX 255
#define RAMPMAX 10
#define RAMPSTEP 1
int rampCtr = 0;
int rampRpm = 0;
int rampPeakCnt = -1;
int rampHalfLen = -1;
int rampLen = 0;
int rampDir = 1;
bool rampRun = false;
volatile int rampSkip = 0;
volatile int velocity;

volatile int rpm = 0;
volatile int tmpRpm = 0;
//portMUX_TYPE myMutex = portMUX_INITIALIZER_UNLOCKED;
TFT_eSPI tft = TFT_eSPI(); /* TFT instance */
lv_disp_draw_buf_t disp_buf;
lv_disp_drv_t disp_drv;
lv_indev_drv_t indev_drv;

lv_color_t buf[HOR_RES * 10];
lv_obj_t *pidchart, *numpadScr;
lv_chart_series_t *ser1;
int setRpm = 0;

// setting PWM properties
const int freq = 5000;
const int ledChannel = 1;
const int resolution = 8;
// unsigned long previousMillis = 0;
// unsigned long currentMillis = 0;
//int dir = 10;
//int motVal = 0;

volatile double sumError = 0;
// volatile double lastError = 0;
//int interval = 100;
//bool pidFlg = false;
lv_obj_t *slider_label;
lv_obj_t *slider;

bool cntFlt = false;
int cntFltCnt = 0;

IRAM_ATTR volatile double dt = 100;
IRAM_ATTR volatile double d0 = 0;
IRAM_ATTR volatile double d1 = 0;
IRAM_ATTR volatile double fd0 = 0;
IRAM_ATTR volatile double fd1 = 0;
IRAM_ATTR volatile double pidN = 5;
IRAM_ATTR volatile double pwm = 0;
IRAM_ATTR volatile double pp = 0;
lv_obj_t *buildNumpadScreen();
extern void openNumpad(lv_obj_t *valPtr);
lv_obj_t *buildConfigScreen();
lv_style_t styleBloom;
#if LV_USE_LOG != 0
/* Serial debugging */
// void my_print(lv_log_level_t level, const char *file, uint32_t line, const char *fn_name, const char *dsc)
void my_print(const char *buf)
{

  // Serial.printf("%s@%d->%s\r\n", file, line, dsc);
  // Serial.flush();
  // Serial.println(buf);
  tft.println(buf);
  while (true)
  {
  }; // hang so that error is visible
}
#endif
/*
int pwmCnt = 0;
int pwmVal = 128;
void IRAM_ATTR onPwmTimer()
{
  digitalWrite(OUTPULSE, LOW);
  //  if(pwmCnt > pwmVal) {
  // digitalWrite(OUTPULSE, LOW);
  //} else {
  // digitalWrite(OUTPULSE, HIGH);
  // }
  pwmCnt++;
  if (pwmCnt > 255)
  {
    pwmCnt = 0;
  }
  digitalWrite(OUTPULSE, HIGH);
}
*/

#define LEDC_CHAN(g, c) LEDC.channel_group[(g)].channel[(c)]
#define LEDC_TIMER(g, t) LEDC.timer_group[(g)].timer[(t)]

void IRAM_ATTR myledcWrite(uint8_t chan, uint32_t duty)
{

  uint8_t group = (chan / 8), channel = (chan % 8);
  LEDC_CHAN(group, channel).duty.duty = duty << 4; // 25 bit (21.4)
  if (duty)
  {
    LEDC_CHAN(group, channel).conf0.sig_out_en = 1; // This is the output enable control bit for channel
    LEDC_CHAN(group, channel).conf1.duty_start = 1; // When duty_num duty_cycle and duty_scale has been configured. these register won't take effect until set duty_start. this bit is automatically cleared by  hardware.
    if (group)
    {
      LEDC_CHAN(group, channel).conf0.low_speed_update = 1;
    }
    else
    {
      LEDC_CHAN(group, channel).conf0.clk_en = 1;
    }
  }
  else
  {
    LEDC_CHAN(group, channel).conf0.sig_out_en = 0; // This is the output enable control bit for channel
    LEDC_CHAN(group, channel).conf1.duty_start = 0; // When duty_num duty_cycle and duty_scale has been configured. these register won't take effect until set duty_start. this bit is automatically cleared by hardware.
    if (group)
    {
      LEDC_CHAN(group, channel).conf0.low_speed_update = 1;
    }
    else
    {
      LEDC_CHAN(group, channel).conf0.clk_en = 0;
    }
  }
}

void IRAM_ATTR __digitalWrite(uint8_t pin, uint8_t val)

{
  if(val) {
     if(pin < 32) 
     {
        GPIO.out_w1ts = ((uint32_t)1 << pin);
     } 
     else if(pin < 34) {
        GPIO.out1_w1ts.val = ((uint32_t)1 << (pin - 32));
     }
  } 
  else
  {
     if(pin < 32) 
     {
        GPIO.out_w1tc = ((uint32_t)1 << pin);
     } 
     else if(pin < 34) 
     {
        GPIO.out1_w1tc.val = ((uint32_t)1 << (pin - 32));
     }
  }
}

void IRAM_ATTR onTimer()
{
//  portENTER_CRITICAL(&myMutex);

  // digitalWrite(OUTPULSE, LOW);
  rpm = m1Ctr - tmpRpm;
  tmpRpm = m1Ctr;


  if (runFlg)
  {
    error = setRpm - m1Ctr;
    velocity = m1Ctr - m1Prev;
    m1Prev = m1Ctr;

//    int sumErrorHist = error;
//    for (int i = NUMHIST - 1; i > 0; i--)
//    {
//      sumErrorHist += errHist[i];
//      errHist[i] = errHist[i - 1];
//    }
//   errHist[0] = error;

    //      if (error > MAXERR)
    //        error = MAXERR;
    //      else if (error < -MAXERR)
    //        error = -MAXERR;


    sumError += error;
    if (sumError > SUMMAX)
      sumError = SUMMAX;
    if (sumError < -SUMMAX)
      sumError = -SUMMAX;

    pwm = error * kp - sumError * ki - velocity * kd;
 
    if (pwm != 0)
    {
      if (pwm > 0)
        pwm += PWMOFFSET;
      else
        pwm -= PWMOFFSET;
    }
    if (pwm > MAXERR)
      pwm = MAXERR;
    else if (pwm < -MAXERR)
      pwm = -MAXERR;

    pp = pwm;
  }
  else
  {
    //m1Ctr = 0;
    //m1Prev = 0;
    error = 0;
    sumError = 0;
    pwm = 0;
    rampRun = false;
    pp = 0;
    for (int i = 0; i < NUMHIST; i++)
    {
      errHist[i] = 0;
    }
  }

  if (pp < 0)
  {

//    digitalWrite(M1PIND2, false);
 //   digitalWrite(M1PIND1, true);
    __digitalWrite(M1PIND2, false);
    __digitalWrite(M1PIND1, true);
    myledcWrite(ledChannel, -pp);
  }
  else
  {
    __digitalWrite(M1PIND1, false);
    __digitalWrite(M1PIND2, true);
    //digitalWrite(M1PIND1, false);
    //digitalWrite(M1PIND2, true);
    myledcWrite(ledChannel, pp);
  }
  //  digitalWrite(OUTPULSE, HIGH);
  if (rampRun) // ramp
  {
    if (rampSkip > 0)
    {
     rampSkip--;
   }
   else
   {
     rampSkip = 10;
      rampCtr++;
      if (rampCtr < rampHalfLen)
      {
        if (rampRpm < RAMPMAX)
        {
          rampRpm += RAMPSTEP;
        }
        else
        {
          rampPeakCnt++;
        }
      }
      else
      {
        if (rampPeakCnt > 0)
        {
          rampPeakCnt--;
        }
        else
        {
          rampRpm -= RAMPSTEP;
        }
      }
      if (rampCtr == rampLen)
      {
        rampCtr = 0;
        rampRpm = 0;
        rampPeakCnt = 0;
        rampHalfLen = rampLen / 2;
        rampDir = rampDir * -1;
      }
   }
      setRpm += rampRpm * rampDir;
  }
//  portEXIT_CRITICAL_ISR(&myMutex);
}

void IRAM_ATTR Ext_INT1_ISR()
{
 // portENTER_CRITICAL(&myMutex);
  digitalWrite(OUTPULSE, LOW);
  long m1Now = (REG_READ(GPIO_IN_REG) & 0x0600000);

  switch (m1Lst)
  {
  case 0:
    if (m1Now == 0x400000)
      m1Ctr++;
    else if (m1Now == 0x200000)
      m1Ctr--;
    else
      cntFlt = true;
    break;
  case 0x400000:
    if (m1Now == 0x600000)
      m1Ctr++;
    else if (m1Now == 0)
      m1Ctr--;
    else
      cntFlt = true;
    break;
  case 0x600000:
    if (m1Now == 0x200000)
      m1Ctr++;
    else if (m1Now == 0x400000)
      m1Ctr--;
    else
      cntFlt = true;
    break;
  case 0x200000:
    if (m1Now == 0)
      m1Ctr++;
    else if (m1Now == 0x600000)
      m1Ctr--;
    else
      cntFlt = true;
    break;
  }
  m1Lst = m1Now;
  digitalWrite(OUTPULSE, HIGH);
//  portEXIT_CRITICAL_ISR(&myMutex);
}

void touch_calibrate()
{
  uint16_t calData[5];
  uint8_t calDataOK = 0;

  // check if calibration file exists and size is correct
  if (SPIFFS.exists(CALIBRATION_FILE))
  {
    if (REPEAT_CAL)
    {
      // Delete if we want to re-calibrate
      SPIFFS.remove(CALIBRATION_FILE);
    }
    else
    {
      File f = SPIFFS.open(CALIBRATION_FILE, "r");
      if (f)
      {
        if (f.readBytes((char *)calData, 14) == 14)
          calDataOK = 1;
        f.close();
      }
    }
  }

  if (calDataOK && !REPEAT_CAL)
  {
    // calibration data valid
    tft.setTouch(calData);
  }
  else
  {
    // data not valid so recalibrate
    tft.fillScreen(TFT_BLACK);
    tft.setCursor(20, 0);
    tft.setTextFont(2);
    tft.setTextSize(1);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);

    tft.println("Touch corners as indicated");

    tft.setTextFont(1);
    tft.println();

    if (REPEAT_CAL)
    {
      tft.setTextColor(TFT_RED, TFT_BLACK);
      tft.println("Set REPEAT_CAL to false to stop this running again!");
    }

    tft.calibrateTouch(calData, TFT_MAGENTA, TFT_BLACK, 15);

    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.println("Calibration complete!");

    // store data
    File f = SPIFFS.open(CALIBRATION_FILE, "w");
    if (f)
    {
      f.write((const unsigned char *)calData, 14);
      f.close();
    }
  }
}

#if LV_USE_LOG != 0
/* Serial debugging */
void my_print(lv_log_level_t level, const char *file, uint32_t line, const char *fn_name, const char *dsc)
{
  Serial.printf("%s@%d->%s\r\n", file, line, dsc);
  Serial.flush();
}
#endif

/* Display flushing */
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)
{
  uint32_t w = (area->x2 - area->x1 + 1);
  uint32_t h = (area->y2 - area->y1 + 1);

  tft.startWrite();
  tft.setAddrWindow(area->x1, area->y1, w, h);
  tft.pushColors(&color_p->full, w * h, true);
  tft.endWrite();

  lv_disp_flush_ready(disp);
}

void my_touchpad_read(lv_indev_drv_t *indev_driver, lv_indev_data_t *data)
{
  uint16_t touchX, touchY;
  bool touched = tft.getTouch(&touchX, &touchY, 600);
  if (!touched)
  {
    data->state = LV_INDEV_STATE_REL;
  }
  else
  {
    data->state = LV_INDEV_STATE_PR;
  }
  if (touchX > HOR_RES || touchY > VER_RES)
  {
  }
  else
  {
    if (3 == tft.getRotation())
    {
      // Shift coordinates
      data->point.x = HOR_RES - touchX;
      data->point.y = VER_RES - touchY;
    }
    else if (1 == tft.getRotation())
    {
      data->point.x = touchX;
      data->point.y = touchY;
    }
  }
}

static void lv_tick_handler(void)
{
  lv_tick_inc(LVGL_TICK_PERIOD);
}

void setup()
{
  pinMode(OUTPULSE, OUTPUT);
  Serial.begin(115200); /* prepare for possible serial debug */

  pinMode(M1PIND1, OUTPUT);
  pinMode(M1PIND2, OUTPUT);

  pinMode(M1QP1, INPUT);
  pinMode(M1QP2, INPUT);
	//	gpio_pullup_en((gpio_num_t) M1QP1);
	//	gpio_pullup_en((gpio_num_t) M1QP2);
  digitalWrite(M1PIND1, false);
  digitalWrite(M1PIND2, true);

  attachInterrupt(M1QP1, Ext_INT1_ISR, CHANGE);
  attachInterrupt(M1QP2, Ext_INT1_ISR, CHANGE);

  timer = timerBegin(0, 80, true);                   // Begin timer with 1 MHz frequency (80MHz/80)
  timerAttachInterrupt(timer, &onTimer, true);       // Attach the interrupt to Timer1
  unsigned int timerFactor = 1000000 / SamplingRate; // Calculate the time interval between two readings, or more accurately, the number of cycles between two readings
  timerAlarmWrite(timer, timerFactor, true);         // Initialize the timer
  timerAlarmEnable(timer);

  /*
    pwmTimer = timerBegin(1, 80, true);                   // Begin timer with 1 MHz frequency (80MHz/80)
    timerAttachInterrupt(pwmTimer, &onPwmTimer, true);       // Attach the interrupt to Timer1
    timerAlarmWrite(pwmTimer, 1000000 / 50000, true);         // Initialize the timer
    timerAlarmEnable(pwmTimer);
  */
  ledcSetup(ledChannel, freq, resolution);
  ledcAttachPin(ledPin, ledChannel);
  lv_init();
  tick.attach_ms(LVGL_TICK_PERIOD, lv_tick_handler);

#if LV_USE_LOG != 0
  lv_log_register_print_cb(my_print); /* register print function for debugging */
#endif

  tft.begin();        /* TFT init */
  tft.setRotation(1); /* Portrait orientation */
  // check file system exists
  if (!SPIFFS.begin())
  {
    Serial.println("Formating file system");
    SPIFFS.format();
    SPIFFS.begin();
  }
  touch_calibrate();
  lv_disp_draw_buf_init(&disp_buf, buf, NULL, HOR_RES * 10);
  lv_disp_drv_init(&disp_drv);
  disp_drv.draw_buf = &disp_buf;
  disp_drv.hor_res = HOR_RES;
  disp_drv.ver_res = VER_RES;
  disp_drv.flush_cb = my_disp_flush;
  lv_disp_drv_register(&disp_drv);
  lv_indev_drv_init(&indev_drv);
  indev_drv.type = LV_INDEV_TYPE_POINTER;
  indev_drv.read_cb = my_touchpad_read;
  lv_indev_drv_register(&indev_drv);
  numpadScr = buildNumpadScreen();
  mainScr = buildConfigScreen();
  for (int i = 0; i < NUMHIST; i++)
  {
    errHist[i] = 0;
  }


#define STACK_SIZE 1000
#define PRIORITY configMAX_PRIORITIES
//  if (cpu_core > 1) {
 //   xTaskCreate(PidTask, "PidTask", STACK_SIZE, NULL, PRIORITY, NULL);
//  } else {
  //  xTaskCreatePinnedToCore(PidTask, "PidTask", STACK_SIZE, engine, PRIORITY, NULL, cpu_core);
 // }


}
// double lstPp;

void loop()
{
    //Serial.printf("%x\r\n",  REG_READ(GPIO_IN_REG));
  lv_task_handler();
  if (rampRun)
  {
    lv_slider_set_value(slider, rampRpm, LV_ANIM_ON);
  //  lv_event_send(slider, LV_EVENT_VALUE_CHANGED, NULL);
  }
  lv_chart_set_next_value(pidchart, ser1, error + 32);
  //lv_chart_set_next_value(pidchart, ser1, m1Ctr + 32);

  /*
      int xp = 240;
      int yp = 80;
      int r = 35;
      float deg1, deg2;
      int ix1, iy1, ix2, iy2;
      tft.fillCircle(xp, yp, r * 2 + 2, TFT_BLACK);
      deg1 = setRpm * 6.28 / 360;
      ix1 = cos(deg1) * r + xp;
      iy1 = sin(deg1) * r + yp;
      tft.drawLine(ix1, iy1, xp, yp, TFT_WHITE);
      tft.fillCircle(xp, yp, 3, TFT_RED);
      tft.fillCircle(ix1, iy1, 3, TFT_RED);
  */

  if (cntFlt)
  {
    cntFltCnt++;
    Serial.print("flt ");
    Serial.println(cntFltCnt);
    cntFlt = 0;
  }
}

//char *nameConfig = "config";

void ramp_event_cb(lv_event_t *e)
{
  lv_event_code_t code = lv_event_get_code(e);

  if (code == LV_EVENT_CLICKED)
  {
    rampCtr = 0;
    rampRpm = 0;
    rampPeakCnt = 0;
    rampLen = 30;
    rampHalfLen = rampLen / 2;
    rampRun = true;
    rampDir = 1;

    //         ledcWrite(ledChannel, 0);
    //         lv_chart_set_next_value(chart, ser1, 0);
  }
}

void stop_event_cb(lv_event_t *e)
{
  lv_event_code_t code = lv_event_get_code(e);

  if (code == LV_EVENT_CLICKED)
  {
    char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */
    setRpm = 0;
    rampRun = false;
    snprintf(buf, 4, "%u", setRpm);
    lv_label_set_text(slider_label, buf);
    //         ledcWrite(ledChannel, 0);
    lv_slider_set_value(slider, setRpm, LV_ANIM_ON);
    //         lv_chart_set_next_value(chart, ser1, 0);
  }
}

void slider_event_cb(lv_event_t *e)
{
  lv_obj_t *slider = lv_event_get_target(e);
  setRpm = lv_slider_get_value(slider) ;
  char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */
  snprintf(buf, 4, "%u", setRpm);
  lv_label_set_text(slider_label, buf);

  //        ledcWrite(1, setRpm);

  //         lv_chart_set_next_value(chart, ser1, v);
}

void sw_event_cb(lv_event_t *e)
{
  lv_event_code_t code = lv_event_get_code(e);
  lv_obj_t *obj = lv_event_get_target(e);
  if (code == LV_EVENT_VALUE_CHANGED)
  {
    runFlg = lv_obj_has_state(obj, LV_STATE_CHECKED);
  }
}

void pid_event_cb(lv_event_t *e)
{
  lv_obj_t *obj = lv_event_get_target(e);
  // lv_obj_t *ta = (lv_obj_t *)lv_event_get_user_data(e);
  if (lv_event_get_code(e) == LV_EVENT_CLICKED)
  {
    openNumpad(obj);
    //    lv_obj_add_state(txtarea, LV_STATE_FOCUSED); /*To be sure the cursor is visible*/

    //    lv_scr_load_anim(numpadScr, LV_SCR_LOAD_ANIM_NONE, 0, 0, false);
  }
}

/*
 void slider_x_event_cb(lv_event_t * e)
{
    lv_obj_t * obj = lv_event_get_target(e);
    int32_t v = lv_slider_get_value(obj);
    lv_chart_set_zoom_x(chart, v);
}

 void slider_y_event_cb(lv_event_t * e)
{
    lv_obj_t * obj = lv_event_get_target(e);
    int32_t v = lv_slider_get_value(obj);
    lv_chart_set_zoom_y(chart, v);
}

*/
lv_obj_t *bloomButton(lv_obj_t *scr,
                      lv_coord_t x, lv_coord_t y,
                      lv_coord_t w, lv_coord_t h,
                      const char *lab, lv_event_cb_t cb)
{

  lv_obj_t *btn1 = lv_btn_create(scr);
  // lv_obj_add_style(btn1, &styleShadow, 0);
  lv_obj_add_style(btn1, &styleBloom, LV_STATE_PRESSED);
  lv_obj_set_pos(btn1, x, y);
  lv_obj_set_size(btn1, w, h);
  lv_obj_add_event_cb(btn1, cb, LV_EVENT_ALL, NULL);
  lv_obj_t *label = lv_label_create(btn1);
  lv_label_set_text(label, lab);
  lv_obj_center(label);
  return btn1;
}

lv_obj_t *floatButton(lv_obj_t *scr, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, double *dval)
{
  char buf[8];
  lv_obj_t *btn = lv_btn_create(scr);
  lv_obj_set_pos(btn, x, y);
  lv_obj_set_size(btn, w, h);
  lv_obj_add_event_cb(btn, pid_event_cb, LV_EVENT_CLICKED, NULL);
  snprintf(buf, 8, "%01.2f", *dval);
  lv_obj_t *label = lv_label_create(btn);
  lv_label_set_text(label, buf);
  btn->user_data = label;
  label->user_data = dval;
  return btn;
}

lv_obj_t *buildConfigScreen()
{
  lv_obj_t *scr = lv_scr_act();
  //scr->user_data = nameConfig;

  pidchart = lv_chart_create(lv_scr_act());
  lv_obj_set_size(pidchart, 240, 100);
  lv_obj_align(pidchart, LV_ALIGN_TOP_MID, 0, 0);
  lv_chart_set_type(pidchart, LV_CHART_TYPE_LINE); /*Show lines and points too*/
  lv_chart_set_range(pidchart, LV_CHART_AXIS_PRIMARY_Y, 0, 64);
  lv_obj_set_style_size(pidchart, 0, LV_PART_INDICATOR);
  /*Add a faded are effect*/
  //    lv_obj_set_style_local_bg_opa(chart, LV_CHART_PART_SERIES, LV_STATE_DEFAULT, LV_OPA_50); /*Max. opa.*/
  //   lv_obj_set_style_local_bg_grad_dir(chart, LV_CHART_PART_SERIES, LV_STATE_DEFAULT, LV_GRAD_DIR_VER);
  //   lv_obj_set_style_local_bg_main_stop(chart, LV_CHART_PART_SERIES, LV_STATE_DEFAULT, 255);    /*Max opa on the top*/
  //   lv_obj_set_style_local_bg_grad_stop(chart, LV_CHART_PART_SERIES, LV_STATE_DEFAULT, 0);      /*Transparent on the bottom*/

  ser1 = lv_chart_add_series(pidchart, lv_color_make(255, 0, 0), LV_CHART_AXIS_PRIMARY_Y);

  bloomButton(scr, 0, 110, 45, 30, "Stop", stop_event_cb);
  floatButton(scr, 50, 110, 45, 30, &kp);
  floatButton(scr, 100, 110, 45, 30, &ki);
  floatButton(scr, 150, 110, 45, 30, &kd);
  bloomButton(scr, 200, 110, 30, 30, "R", ramp_event_cb);

  lv_obj_t *sw = lv_switch_create(scr);
  lv_obj_set_pos(sw, 240, 110);
  lv_obj_set_size(sw, 50, 30);
  lv_obj_add_event_cb(sw, sw_event_cb, LV_EVENT_ALL, NULL);

  slider = lv_slider_create(scr);
  lv_obj_set_pos(slider, 20, 170);
  lv_obj_set_size(slider, 280, 30);
  lv_obj_add_event_cb(slider, slider_event_cb, LV_EVENT_VALUE_CHANGED, NULL);
  lv_slider_set_range(slider, 0, 255);

  slider_label = lv_label_create(scr);
  lv_label_set_text(slider_label, "0%");
  lv_obj_align_to(slider_label, slider, LV_ALIGN_CENTER, 0, 0);

  return scr;
}
